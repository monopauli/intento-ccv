// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: item/buyer.proto

package types

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgPrepayment struct {
	Buyer   string `protobuf:"bytes,1,opt,name=buyer,proto3" json:"buyer,omitempty"`
	Itemid  uint64 `protobuf:"varint,2,opt,name=itemid,proto3" json:"itemid,omitempty"`
	Deposit int64  `protobuf:"varint,3,opt,name=deposit,proto3" json:"deposit,omitempty"`
}

func (m *MsgPrepayment) Reset()         { *m = MsgPrepayment{} }
func (m *MsgPrepayment) String() string { return proto.CompactTextString(m) }
func (*MsgPrepayment) ProtoMessage()    {}
func (*MsgPrepayment) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c7d3b0327021eb7, []int{0}
}
func (m *MsgPrepayment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPrepayment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPrepayment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPrepayment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPrepayment.Merge(m, src)
}
func (m *MsgPrepayment) XXX_Size() int {
	return m.Size()
}
func (m *MsgPrepayment) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPrepayment.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPrepayment proto.InternalMessageInfo

func (m *MsgPrepayment) GetBuyer() string {
	if m != nil {
		return m.Buyer
	}
	return ""
}

func (m *MsgPrepayment) GetItemid() uint64 {
	if m != nil {
		return m.Itemid
	}
	return 0
}

func (m *MsgPrepayment) GetDeposit() int64 {
	if m != nil {
		return m.Deposit
	}
	return 0
}

type MsgUpdateBuyer struct {
	Buyer   string `protobuf:"bytes,1,opt,name=buyer,proto3" json:"buyer,omitempty"`
	Itemid  uint64 `protobuf:"varint,2,opt,name=itemid,proto3" json:"itemid,omitempty"`
	Deposit int64  `protobuf:"varint,3,opt,name=deposit,proto3" json:"deposit,omitempty"`
}

func (m *MsgUpdateBuyer) Reset()         { *m = MsgUpdateBuyer{} }
func (m *MsgUpdateBuyer) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateBuyer) ProtoMessage()    {}
func (*MsgUpdateBuyer) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c7d3b0327021eb7, []int{1}
}
func (m *MsgUpdateBuyer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateBuyer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateBuyer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateBuyer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateBuyer.Merge(m, src)
}
func (m *MsgUpdateBuyer) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateBuyer) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateBuyer.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateBuyer proto.InternalMessageInfo

func (m *MsgUpdateBuyer) GetBuyer() string {
	if m != nil {
		return m.Buyer
	}
	return ""
}

func (m *MsgUpdateBuyer) GetItemid() uint64 {
	if m != nil {
		return m.Itemid
	}
	return 0
}

func (m *MsgUpdateBuyer) GetDeposit() int64 {
	if m != nil {
		return m.Deposit
	}
	return 0
}

type MsgWithdrawal struct {
	Buyer  string `protobuf:"bytes,1,opt,name=buyer,proto3" json:"buyer,omitempty"`
	Itemid uint64 `protobuf:"varint,2,opt,name=itemid,proto3" json:"itemid,omitempty"`
}

func (m *MsgWithdrawal) Reset()         { *m = MsgWithdrawal{} }
func (m *MsgWithdrawal) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawal) ProtoMessage()    {}
func (*MsgWithdrawal) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c7d3b0327021eb7, []int{2}
}
func (m *MsgWithdrawal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawal.Merge(m, src)
}
func (m *MsgWithdrawal) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawal) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawal.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawal proto.InternalMessageInfo

func (m *MsgWithdrawal) GetBuyer() string {
	if m != nil {
		return m.Buyer
	}
	return ""
}

func (m *MsgWithdrawal) GetItemid() uint64 {
	if m != nil {
		return m.Itemid
	}
	return 0
}

type MsgItemTransfer struct {
	Buyer  string `protobuf:"bytes,1,opt,name=buyer,proto3" json:"buyer,omitempty"`
	Itemid uint64 `protobuf:"varint,2,opt,name=itemid,proto3" json:"itemid,omitempty"`
}

func (m *MsgItemTransfer) Reset()         { *m = MsgItemTransfer{} }
func (m *MsgItemTransfer) String() string { return proto.CompactTextString(m) }
func (*MsgItemTransfer) ProtoMessage()    {}
func (*MsgItemTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c7d3b0327021eb7, []int{3}
}
func (m *MsgItemTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgItemTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgItemTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgItemTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgItemTransfer.Merge(m, src)
}
func (m *MsgItemTransfer) XXX_Size() int {
	return m.Size()
}
func (m *MsgItemTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgItemTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_MsgItemTransfer proto.InternalMessageInfo

func (m *MsgItemTransfer) GetBuyer() string {
	if m != nil {
		return m.Buyer
	}
	return ""
}

func (m *MsgItemTransfer) GetItemid() uint64 {
	if m != nil {
		return m.Itemid
	}
	return 0
}

type MsgItemRating struct {
	Buyer  string `protobuf:"bytes,1,opt,name=buyer,proto3" json:"buyer,omitempty"`
	Itemid uint64 `protobuf:"varint,2,opt,name=itemid,proto3" json:"itemid,omitempty"`
	Rating int64  `protobuf:"varint,3,opt,name=rating,proto3" json:"rating,omitempty"`
	Note   string `protobuf:"bytes,4,opt,name=note,proto3" json:"note,omitempty"`
}

func (m *MsgItemRating) Reset()         { *m = MsgItemRating{} }
func (m *MsgItemRating) String() string { return proto.CompactTextString(m) }
func (*MsgItemRating) ProtoMessage()    {}
func (*MsgItemRating) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c7d3b0327021eb7, []int{4}
}
func (m *MsgItemRating) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgItemRating) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgItemRating.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgItemRating) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgItemRating.Merge(m, src)
}
func (m *MsgItemRating) XXX_Size() int {
	return m.Size()
}
func (m *MsgItemRating) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgItemRating.DiscardUnknown(m)
}

var xxx_messageInfo_MsgItemRating proto.InternalMessageInfo

func (m *MsgItemRating) GetBuyer() string {
	if m != nil {
		return m.Buyer
	}
	return ""
}

func (m *MsgItemRating) GetItemid() uint64 {
	if m != nil {
		return m.Itemid
	}
	return 0
}

func (m *MsgItemRating) GetRating() int64 {
	if m != nil {
		return m.Rating
	}
	return 0
}

func (m *MsgItemRating) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func init() {
	proto.RegisterType((*MsgPrepayment)(nil), "trstlabs.trst.trst.MsgPrepayment")
	proto.RegisterType((*MsgUpdateBuyer)(nil), "trstlabs.trst.trst.MsgUpdateBuyer")
	proto.RegisterType((*MsgWithdrawal)(nil), "trstlabs.trst.trst.MsgWithdrawal")
	proto.RegisterType((*MsgItemTransfer)(nil), "trstlabs.trst.trst.MsgItemTransfer")
	proto.RegisterType((*MsgItemRating)(nil), "trstlabs.trst.trst.MsgItemRating")
}

func init() { proto.RegisterFile("item/buyer.proto", fileDescriptor_2c7d3b0327021eb7) }

var fileDescriptor_2c7d3b0327021eb7 = []byte{
	// 276 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x91, 0xcd, 0x4a, 0xf4, 0x30,
	0x14, 0x86, 0x9b, 0x6f, 0xfa, 0x55, 0x0c, 0xf8, 0x43, 0x90, 0xa1, 0xab, 0x50, 0x0a, 0x42, 0x57,
	0xed, 0xc2, 0xb5, 0x0c, 0xcc, 0xce, 0x45, 0x41, 0x8a, 0x32, 0xe2, 0x2e, 0xb5, 0xb1, 0x13, 0x98,
	0x36, 0x21, 0x39, 0x83, 0xf6, 0x2e, 0xbc, 0x2c, 0x97, 0xb3, 0x74, 0x29, 0xed, 0x8d, 0x48, 0x8f,
	0x9d, 0x0b, 0x28, 0xb8, 0x09, 0xef, 0xb3, 0x38, 0x4f, 0xce, 0xe1, 0xa5, 0x97, 0x0a, 0x64, 0x93,
	0x95, 0xfb, 0x4e, 0xda, 0xd4, 0x58, 0x0d, 0x9a, 0x31, 0xb0, 0x0e, 0x76, 0xa2, 0x74, 0xe9, 0x18,
	0xf0, 0x89, 0x37, 0xf4, 0x2c, 0x77, 0xf5, 0xbd, 0x95, 0x46, 0x74, 0x8d, 0x6c, 0x81, 0x5d, 0xd1,
	0xff, 0x38, 0x13, 0x92, 0x88, 0x24, 0xa7, 0xc5, 0x2f, 0xb0, 0x25, 0x0d, 0x46, 0x9d, 0xaa, 0xc2,
	0x7f, 0x11, 0x49, 0xfc, 0x62, 0x22, 0x16, 0xd2, 0x93, 0x4a, 0x1a, 0xed, 0x14, 0x84, 0x8b, 0x88,
	0x24, 0x8b, 0xe2, 0x88, 0xf1, 0x13, 0x3d, 0xcf, 0x5d, 0xfd, 0x68, 0x2a, 0x01, 0x72, 0x8d, 0x8e,
	0xbf, 0x32, 0xdf, 0xe2, 0xca, 0x1b, 0x05, 0xdb, 0xca, 0x8a, 0x37, 0xb1, 0x9b, 0x27, 0x8e, 0x57,
	0xf4, 0x22, 0x77, 0xf5, 0x1d, 0xc8, 0xe6, 0xc1, 0x8a, 0xd6, 0xbd, 0xce, 0xdd, 0x2c, 0x56, 0xf8,
	0xff, 0x28, 0x28, 0x04, 0xa8, 0xb6, 0x9e, 0x79, 0xd8, 0x92, 0x06, 0x16, 0xe7, 0xa6, 0xbb, 0x26,
	0x62, 0x8c, 0xfa, 0xad, 0x06, 0x19, 0xfa, 0x28, 0xc1, 0xbc, 0x5e, 0x7d, 0xf6, 0x9c, 0x1c, 0x7a,
	0x4e, 0xbe, 0x7b, 0x4e, 0x3e, 0x06, 0xee, 0x1d, 0x06, 0xee, 0x7d, 0x0d, 0xdc, 0x7b, 0xbe, 0xae,
	0x15, 0x6c, 0xf7, 0x65, 0xfa, 0xa2, 0x9b, 0xec, 0x58, 0x2b, 0x86, 0xec, 0x3d, 0xc3, 0xe2, 0xa1,
	0x33, 0xd2, 0x95, 0x01, 0x36, 0x7f, 0xf3, 0x13, 0x00, 0x00, 0xff, 0xff, 0xa6, 0x8d, 0x7a, 0xd5,
	0x0d, 0x02, 0x00, 0x00,
}

func (m *MsgPrepayment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPrepayment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPrepayment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Deposit != 0 {
		i = encodeVarintBuyer(dAtA, i, uint64(m.Deposit))
		i--
		dAtA[i] = 0x18
	}
	if m.Itemid != 0 {
		i = encodeVarintBuyer(dAtA, i, uint64(m.Itemid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Buyer) > 0 {
		i -= len(m.Buyer)
		copy(dAtA[i:], m.Buyer)
		i = encodeVarintBuyer(dAtA, i, uint64(len(m.Buyer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateBuyer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateBuyer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateBuyer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Deposit != 0 {
		i = encodeVarintBuyer(dAtA, i, uint64(m.Deposit))
		i--
		dAtA[i] = 0x18
	}
	if m.Itemid != 0 {
		i = encodeVarintBuyer(dAtA, i, uint64(m.Itemid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Buyer) > 0 {
		i -= len(m.Buyer)
		copy(dAtA[i:], m.Buyer)
		i = encodeVarintBuyer(dAtA, i, uint64(len(m.Buyer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Itemid != 0 {
		i = encodeVarintBuyer(dAtA, i, uint64(m.Itemid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Buyer) > 0 {
		i -= len(m.Buyer)
		copy(dAtA[i:], m.Buyer)
		i = encodeVarintBuyer(dAtA, i, uint64(len(m.Buyer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgItemTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgItemTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgItemTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Itemid != 0 {
		i = encodeVarintBuyer(dAtA, i, uint64(m.Itemid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Buyer) > 0 {
		i -= len(m.Buyer)
		copy(dAtA[i:], m.Buyer)
		i = encodeVarintBuyer(dAtA, i, uint64(len(m.Buyer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgItemRating) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgItemRating) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgItemRating) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Note) > 0 {
		i -= len(m.Note)
		copy(dAtA[i:], m.Note)
		i = encodeVarintBuyer(dAtA, i, uint64(len(m.Note)))
		i--
		dAtA[i] = 0x22
	}
	if m.Rating != 0 {
		i = encodeVarintBuyer(dAtA, i, uint64(m.Rating))
		i--
		dAtA[i] = 0x18
	}
	if m.Itemid != 0 {
		i = encodeVarintBuyer(dAtA, i, uint64(m.Itemid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Buyer) > 0 {
		i -= len(m.Buyer)
		copy(dAtA[i:], m.Buyer)
		i = encodeVarintBuyer(dAtA, i, uint64(len(m.Buyer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBuyer(dAtA []byte, offset int, v uint64) int {
	offset -= sovBuyer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgPrepayment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Buyer)
	if l > 0 {
		n += 1 + l + sovBuyer(uint64(l))
	}
	if m.Itemid != 0 {
		n += 1 + sovBuyer(uint64(m.Itemid))
	}
	if m.Deposit != 0 {
		n += 1 + sovBuyer(uint64(m.Deposit))
	}
	return n
}

func (m *MsgUpdateBuyer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Buyer)
	if l > 0 {
		n += 1 + l + sovBuyer(uint64(l))
	}
	if m.Itemid != 0 {
		n += 1 + sovBuyer(uint64(m.Itemid))
	}
	if m.Deposit != 0 {
		n += 1 + sovBuyer(uint64(m.Deposit))
	}
	return n
}

func (m *MsgWithdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Buyer)
	if l > 0 {
		n += 1 + l + sovBuyer(uint64(l))
	}
	if m.Itemid != 0 {
		n += 1 + sovBuyer(uint64(m.Itemid))
	}
	return n
}

func (m *MsgItemTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Buyer)
	if l > 0 {
		n += 1 + l + sovBuyer(uint64(l))
	}
	if m.Itemid != 0 {
		n += 1 + sovBuyer(uint64(m.Itemid))
	}
	return n
}

func (m *MsgItemRating) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Buyer)
	if l > 0 {
		n += 1 + l + sovBuyer(uint64(l))
	}
	if m.Itemid != 0 {
		n += 1 + sovBuyer(uint64(m.Itemid))
	}
	if m.Rating != 0 {
		n += 1 + sovBuyer(uint64(m.Rating))
	}
	l = len(m.Note)
	if l > 0 {
		n += 1 + l + sovBuyer(uint64(l))
	}
	return n
}

func sovBuyer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBuyer(x uint64) (n int) {
	return sovBuyer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgPrepayment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuyer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPrepayment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPrepayment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuyer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBuyer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Itemid", wireType)
			}
			m.Itemid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Itemid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			m.Deposit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deposit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuyer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBuyer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateBuyer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuyer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateBuyer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateBuyer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuyer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBuyer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Itemid", wireType)
			}
			m.Itemid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Itemid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			m.Deposit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deposit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuyer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBuyer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuyer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuyer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBuyer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Itemid", wireType)
			}
			m.Itemid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Itemid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuyer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBuyer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgItemTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuyer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgItemTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgItemTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuyer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBuyer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Itemid", wireType)
			}
			m.Itemid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Itemid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuyer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBuyer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgItemRating) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuyer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgItemRating: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgItemRating: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuyer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBuyer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Itemid", wireType)
			}
			m.Itemid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Itemid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rating", wireType)
			}
			m.Rating = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rating |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuyer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBuyer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBuyer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBuyer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBuyer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBuyer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBuyer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBuyer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBuyer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBuyer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBuyer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBuyer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBuyer = fmt.Errorf("proto: unexpected end of group")
)
